package main

import (
	"fmt"
	"time"
)

/**
|-------------------------------------------------------------------------------------------------
|
|	goroutine 并发编程
|
|	go 关键字定义并发编程
|
|	协程 coroutine
|		* 协程相当于轻量级的线程，作用和线程差不多，都是用来并发的去执行一些任务的
|		* 协程是非抢占式多任务处理，由协程主动交出控制权。线程在任何时候都会被操作系统进行切换，
|		  所以线程就是抢占式多任务处理。
|		* 协程是编译器/解释器/虚拟机层面的多任务，不是操作系统层面的多任务
|		* 多个协程可能在一个或多个线程上运行
|
|	go run -race xxx.go	// 检查数据并发任务时数据访问的冲突
|
|	调度器切换协程的切换点
|		IO/select
|		channel
|		等待锁
|		函数调用（有时）
|		runtime.Gosched()
|		以上都只是参考，不能保证切换，不能保证在其他地方不切换
|
|-------------------------------------------------------------------------------------------------
*/

func printHello(ii int) {
	for {
		fmt.Printf("Hello from goroutine %d\n", ii)
	}
}

func main() {
	//var a [10]int
	// 1000 个人并发执行下面的程序
	for i := 0; i < 1000; i++ {
		// 这一段代码相当于 go printHello(ii)
		// go func(ii int) {}() 的方式是匿名函数的方式
		// 这段代码的意思是并发的执行这个函数
		go func(ii int) {
			for {
				fmt.Printf("Hello from goroutine %d\n", i)
				//a[ii]++	// 此时死循环，当前这个协程不会交出控制权
				//runtime.Gosched()	// 手动交出控制权，让调度器自己调度，这种方式一般情况下不会用到
			}
		}(i)
	}
	time.Sleep(time.Minute)	// 让程序暂停，以便能让 go 并发的输出能打印出来
	//fmt.Println(a)
}
